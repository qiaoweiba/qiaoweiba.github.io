<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>乔尾巴的技术屋</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qiaoweiba.com/"/>
  <updated>2017-09-28T14:56:56.940Z</updated>
  <id>http://qiaoweiba.com/</id>
  
  <author>
    <name>qiaoweiba</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://qiaoweiba.com/2017/09/28/1/"/>
    <id>http://qiaoweiba.com/2017/09/28/1/</id>
    <published>2017-09-28T03:56:32.000Z</published>
    <updated>2017-09-28T14:56:56.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式确保某一个类只有一个实例，而且能自动实例化，并向整个系统提供这个实例。单例模式的作用域就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个。例如，一台计算机上可以连接多台打印机，但是这个计算机上的打印程序只能有一个，这里就可以通过单例模式来避免两个打印机同时输出到打印机中，即在整个打印过程中只有一个打印程序的实例。<br><strong>单例模式需要保证系统中只有一个该类的实例，因此类的构造函数必须为私有，同时单例类必须提供一个全局访问点。</strong><br><a id="more"></a></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>1.饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//饿汉式：在类加载时就会实例化该类的对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">new</span> Singleton01();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>饿汉式由于在使用时之前对象已经创建好，因此，饿汉式实现的单例对象是线程安全的。</p>
<p>2.懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//懒汉式：在类需要被使用的时候才实例化该类的对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton02 instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line"> 			<span class="comment">//在这个地方,多线程的时候,可能A线程挂起， </span></div><div class="line">            <span class="comment">//此时instance属性还是null,那么B线程可能也判断条件为true而执行new操作。  </span></div><div class="line">            <span class="comment">//然后A线程可以执行的时候就会new个对象,线程B也会new个对象。  </span></div><div class="line">            <span class="comment">//就不能保证内存的唯一性，也即线程不安全。  </span></div><div class="line">            instance = <span class="keyword">new</span> Singleton02();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>懒汉式由于在使用的时候才实例化该类的对象，当多线程时存在安全隐患。</p>
<p>3.懒汉式–进阶版（双检查锁机制）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//双检查锁机制：只有当instance为null即没有创建的时候，需要加锁操作。用加锁机制</span></div><div class="line"><span class="comment">//    确保在多线程下只创建一个实例，并且用两个if判断提高效率并确保只生成一个实例。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span> </span>&#123;</div><div class="line">    <span class="comment">//volatile保证其修饰的值在线程间的可见性</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> <span class="keyword">static</span> Singleton03 instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton03</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton03 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">synchronized</span> (Singleton03.class) &#123;</div><div class="line">                    <span class="comment">// 再次判断instance是否为空</span></div><div class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                        instance = <span class="keyword">new</span> Singleton03();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用双重锁机制即可以子多线程下安全的使用单例模式，但双检查锁机制实现起来比较复杂，容易出错，可以使用下面的解法。</p>
<p>4.static代码块实现单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//static代码块：由于static在类加载时只调用一次，因此可保证只生成一个实例。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton04</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton04 instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton04</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton04();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton04 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态代码块的方式实现单例类，虽然不会存在多线程安全问题，但是也会过早地创建实例，从而降低内存的使用效率。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式特点：</p>
<blockquote>
<p>1.任何情况下，单例类永远只有一个实例存在；<br>2.单例需要为整个系统提供一个唯一的实例。</p>
</blockquote>
<p>单例模式优点：</p>
<blockquote>
<p>1.减少内存的使用；<br>2.单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例；<br>3.由于类控制了实例化过程，所以类可以灵活地更改实例化过程。   </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;单例模式确保某一个类只有一个实例，而且能自动实例化，并向整个系统提供这个实例。单例模式的作用域就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个。例如，一台计算机上可以连接多台打印机，但是这个计算机上的打印程序只能有一个，这里就可以通过单例模式来避免两个打印机同时输出到打印机中，即在整个打印过程中只有一个打印程序的实例。&lt;br&gt;&lt;strong&gt;单例模式需要保证系统中只有一个该类的实例，因此类的构造函数必须为私有，同时单例类必须提供一个全局访问点。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后台" scheme="http://qiaoweiba.com/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="设计模式" scheme="http://qiaoweiba.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码(Java 8)</title>
    <link href="http://qiaoweiba.com/2017/08/28/1/"/>
    <id>http://qiaoweiba.com/2017/08/28/1/</id>
    <published>2017-08-28T03:56:32.000Z</published>
    <updated>2017-09-28T14:19:02.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><p>Map作为一种典型的数据结构，是存储key-value键值对的集合类，key的值可以为null，但必须是唯一的。 HashMap实现了Map接口，因此也继承了这一特性。下面我们来分析一下HashMap的主要源码和实现过程，以便对HashMap有更深入的理解。<br>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line"><span class="class">   	<span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
</code></pre><p>HashMap实现了Map接口，继承了AbstractMap。AbstractMap实现了Map的主要抽象函数，从而减少了HashMap实现接口的工作量。<br><a id="more"></a></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认初始容量，即桶的数量，16</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 最大容量</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">// 默认装载因子</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">//桶中的元素大于此阀值，且HashMap中所有元素总数大于MIN_TREEIFY_CAPACITY时，单向链表转成树（红黑树）</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; <span class="comment">//当桶中的元素小于此阀值时，树转成单向链表</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">//HashMap中所有元素总数小于此值时，即使桶中元素超过TREEIFY_THRESHOLD也不转成树</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//桶</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</div><div class="line"></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line"></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//指定初始容量和装载因子</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                              initialCapacity);</div><div class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">           initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                              loadFactor);</div><div class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">   &#125;</div><div class="line"><span class="comment">//指定加载因子</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">   &#125;</div><div class="line"><span class="comment">//默认构造方法，装载因子为默认值0.75</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></div><div class="line">   &#125;</div><div class="line">   <span class="comment">//使用一个Map来初始化一个HashMap</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">       putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>put方法大致思路如下：</p>
<ol>
<li>对key的hashCode()做hash，然后再计算index;</li>
<li>如果没碰撞直接放到bucket里；</li>
<li>如果碰撞了，以链表的形式存在buckets后；</li>
<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li>
<li>如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>如果bucket满了(超过load factor*current capacity)，就要resize。</li>
</ol>
<p>具体代码的实现如下：<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">	<span class="comment">// 对key的hashCode()做hash</span></div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">	<span class="comment">// tab为空则创建</span></div><div class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">           n = (tab = resize()).length;</div><div class="line">	<span class="comment">// 计算index，并对null做处理</span></div><div class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">       <span class="keyword">else</span> &#123;</div><div class="line">           Node&lt;K,V&gt; e; K k;</div><div class="line">		<span class="comment">// 直接命中节点</span></div><div class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">               e = p;</div><div class="line">		<span class="comment">// 该链为树</span></div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">		<span class="comment">// 该链为链表</span></div><div class="line">           <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">				<span class="comment">// 没有找到，则新建节点加入链表中</span></div><div class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                           treeifyBin(tab, hash);</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   p = e;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">		<span class="comment">// 找到则覆盖原值，并将原值返回</span></div><div class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">               V oldValue = e.value;</div><div class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                   e.value = value;</div><div class="line">               afterNodeAccess(e);</div><div class="line">               <span class="keyword">return</span> oldValue;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       ++modCount;</div><div class="line">	<span class="comment">// 容量超过load factor*current capacity，扩容</span></div><div class="line">       <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">           resize();</div><div class="line">       afterNodeInsertion(evict);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>get方法大致思路如下：</p>
<ol>
<li><p>bucket里直接命中,则返回该处的值；</p>
</li>
<li><p>如果有冲突，则通过key.equals(k)去查找对应的entry:</p>
<blockquote>
<p>若为树，则在树中通过key.equals(k)查找，O(logn)；<br>若为链表，则在链表中通过key.equals(k)查找，O(n)。</p>
</blockquote>
</li>
</ol>
<p>具体代码的实现如下：<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">       Node&lt;K,V&gt; e;</div><div class="line">       <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 直接命中</span></div><div class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">               <span class="keyword">return</span> first;</div><div class="line">		 <span class="comment">// 未命中</span></div><div class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">//在树中查找</span></div><div class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">			<span class="comment">//在链表中查找</span></div><div class="line">               <span class="keyword">do</span> &#123;</div><div class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                       <span class="keyword">return</span> e;</div><div class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">       Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">       <span class="keyword">int</span> oldThr = threshold;</div><div class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">// 容量超过最大值就不再扩容</span></div><div class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">               threshold = Integer.MAX_VALUE;</div><div class="line">               <span class="keyword">return</span> oldTab;</div><div class="line">           &#125;</div><div class="line">		<span class="comment">//没有超过最大值，就扩容为原来的2倍</span></div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">           newCap = oldThr;</div><div class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">       &#125;</div><div class="line">	<span class="comment">// 计算新的扩容上限</span></div><div class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">       &#125;</div><div class="line">       threshold = newThr;</div><div class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">       table = newTab;</div><div class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 把每个bucket都移动到新的buckets中</span></div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">               Node&lt;K,V&gt; e;</div><div class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                   oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                       Node&lt;K,V&gt; next;</div><div class="line">                       <span class="keyword">do</span> &#123;</div><div class="line">                           next = e.next;</div><div class="line">						<span class="comment">// 扩容后仍为原索引</span></div><div class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                   loHead = e;</div><div class="line">                               <span class="keyword">else</span></div><div class="line">                                   loTail.next = e;</div><div class="line">                               loTail = e;</div><div class="line">                           &#125;</div><div class="line">						<span class="comment">// 扩容后为原索引+oldCap</span></div><div class="line">                           <span class="keyword">else</span> &#123;</div><div class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                   hiHead = e;</div><div class="line">                               <span class="keyword">else</span></div><div class="line">                                   hiTail.next = e;</div><div class="line">                               hiTail = e;</div><div class="line">                           &#125;</div><div class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">					<span class="comment">// 原索引放到bucket里</span></div><div class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                           loTail.next = <span class="keyword">null</span>;</div><div class="line">                           newTab[j] = loHead;</div><div class="line">                       &#125;</div><div class="line">					<span class="comment">// 原索引+oldCap放到bucket里</span></div><div class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                           hiTail.next = <span class="keyword">null</span>;</div><div class="line">                           newTab[j + oldCap] = hiHead;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> newTab;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="hash函数的实现"><a href="#hash函数的实现" class="headerlink" title="hash函数的实现"></a>hash函数的实现</h2><p>在进行get和put的过程中，都需要计算下标，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，hashCode()计算hash的代码如下：<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。在设计hash函数时，由于table的长度n为2的幂，而计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)：<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(n - <span class="number">1</span>) &amp; hash</div></pre></td></tr></table></figure></p>
<p>因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用<code>O(logn)</code>的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。如果还是产生了频繁的碰撞，使用树来处理频繁的碰撞。</p>
<h2 id="HashMap的常见问题"><a href="#HashMap的常见问题" class="headerlink" title="HashMap的常见问题"></a>HashMap的常见问题</h2><h3 id="1-HashMap的工作原理"><a href="#1-HashMap的工作原理" class="headerlink" title="1. HashMap的工作原理"></a>1. HashMap的工作原理</h3><p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p>
<h3 id="2-equals-和hashCode-在HashMap中的作用"><a href="#2-equals-和hashCode-在HashMap中的作用" class="headerlink" title="2. equals()和hashCode()在HashMap中的作用"></a>2. equals()和hashCode()在HashMap中的作用</h3><p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。</p>
<h3 id="3-hash的实现原理及目的"><a href="#3-hash的实现原理及目的" class="headerlink" title="3. hash的实现原理及目的"></a>3. hash的实现原理及目的</h3><p>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HashMap源码分析&quot;&gt;&lt;a href=&quot;#HashMap源码分析&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码分析&quot;&gt;&lt;/a&gt;HashMap源码分析&lt;/h1&gt;&lt;p&gt;Map作为一种典型的数据结构，是存储key-value键值对的集合类，key的值可以为null，但必须是唯一的。 HashMap实现了Map接口，因此也继承了这一特性。下面我们来分析一下HashMap的主要源码和实现过程，以便对HashMap有更深入的理解。&lt;br&gt;在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashMap&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractMap&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;   	&lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Map&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;HashMap实现了Map接口，继承了AbstractMap。AbstractMap实现了Map的主要抽象函数，从而减少了HashMap实现接口的工作量。&lt;br&gt;
    
    </summary>
    
      <category term="后台" scheme="http://qiaoweiba.com/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="Java" scheme="http://qiaoweiba.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown笔记</title>
    <link href="http://qiaoweiba.com/2017/08/27/1/"/>
    <id>http://qiaoweiba.com/2017/08/27/1/</id>
    <published>2017-08-27T12:18:00.000Z</published>
    <updated>2017-08-29T09:07:00.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="段落、标题、区块代码"><a href="#段落、标题、区块代码" class="headerlink" title="段落、标题、区块代码"></a>段落、标题、区块代码</h1><p>Markdown 支持两种标题的语法，Setext 和 atx 形式。<br>Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。<br>区块引用则使用 ‘&gt;’ 角括号。</p>
<h1 id="A-First-Level-Header"><a href="#A-First-Level-Header" class="headerlink" title="A First Level Header"></a>A First Level Header</h1><h2 id="A-Second-Level-Header"><a href="#A-Second-Level-Header" class="headerlink" title="A Second Level Header"></a>A Second Level Header</h2><a id="more"></a>
<p>Now is the time for all good men to come to<br>the aid of their country. This is just a<br>regular paragraph.</p>
<p>The quick brown fox jumped over the lazy<br>dog’s back.</p>
<h3 id="Header-3"><a href="#Header-3" class="headerlink" title="Header 3"></a>Header 3</h3><blockquote>
<p>This is a blockquote.</p>
<p>This is the second paragraph in the blockquote.</p>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.<br>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
<blockquote>
<h2 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h2></blockquote>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre><h3 id="This-is-an-H3-in-a-blockquote"><a href="#This-is-an-H3-in-a-blockquote" class="headerlink" title="This is an H3 in a blockquote"></a>This is an H3 in a blockquote</h3></blockquote>
<h1 id="修辞和强调"><a href="#修辞和强调" class="headerlink" title="修辞和强调"></a>修辞和强调</h1><p>星号和底线来标记需要强调的区段</p>
<p>Some of these words <em>are emphasized</em>.<br><br>Some of these words <em>are emphasized also</em>.<br><br>Use two asterisks for <strong>strong emphasis</strong>.<br><br>Or, if you prefer, <strong>use two underscores instead</strong>.</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
<li>yellow</li>
</ul>
<hr>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
</li>
</ul>
<hr>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title="*"></a><em>*</em></h2><hr>
<ol>
<li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p>
<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p>
<ul>
<li>A list item with a blockquote:</li>
</ul>
<blockquote>
<p>This is a blockquote<br>inside a list item.</p>
<ul>
<li>一列表项包含一个列表区块：</li>
</ul>
</blockquote>
<p>   &lt;代码写在这&gt;</p>
</li>
</ol>
<ol>
<li>What a great season.</li>
<li>1986. What a great season.</li>
</ol>
<p>Here is an example of AppleScript:</p>
<pre><code>tell application &quot;Foo&quot;
    beep
end tell

&lt;div class=&quot;footer&quot;&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;
</code></pre><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。</p>
<p>行内式：</p>
<pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.
</code></pre><p>参考式：               </p>
<pre><code>This is [an example][id] reference-style link.
[id]: http://example.com/  &quot;Optional Title Here&quot;
</code></pre><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<pre><code>See my [About](/about/) page for details.
</code></pre><p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<pre><code>[foo]: http://example.com/  &quot;Optional                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Title Here&quot;
[foo]: http://example.com/  &apos;Optional Title Here&apos;
[foo]: http://example.com/  (Optional Title Here)    
</code></pre><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>$E=mc^2$<br><br>$\cos 2\theta = \cos^2 \theta - \sin^2 \theta = 2 \cos^2 \theta - 1$</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;段落、标题、区块代码&quot;&gt;&lt;a href=&quot;#段落、标题、区块代码&quot; class=&quot;headerlink&quot; title=&quot;段落、标题、区块代码&quot;&gt;&lt;/a&gt;段落、标题、区块代码&lt;/h1&gt;&lt;p&gt;Markdown 支持两种标题的语法，Setext 和 atx 形式。&lt;br&gt;Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。&lt;br&gt;区块引用则使用 ‘&amp;gt;’ 角括号。&lt;/p&gt;
&lt;h1 id=&quot;A-First-Level-Header&quot;&gt;&lt;a href=&quot;#A-First-Level-Header&quot; class=&quot;headerlink&quot; title=&quot;A First Level Header&quot;&gt;&lt;/a&gt;A First Level Header&lt;/h1&gt;&lt;h2 id=&quot;A-Second-Level-Header&quot;&gt;&lt;a href=&quot;#A-Second-Level-Header&quot; class=&quot;headerlink&quot; title=&quot;A Second Level Header&quot;&gt;&lt;/a&gt;A Second Level Header&lt;/h2&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://qiaoweiba.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="MarkDown" scheme="http://qiaoweiba.com/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJQuickKey</title>
    <link href="http://qiaoweiba.com/2017/08/15/1/"/>
    <id>http://qiaoweiba.com/2017/08/15/1/</id>
    <published>2017-08-15T13:40:24.000Z</published>
    <updated>2017-08-29T09:05:47.540Z</updated>
    
    <content type="html"><![CDATA[<p>#IntelliJ快捷键</p>
<p>IntelliJ号称最好用的Java编辑器，功能确实也够强大，配合上快捷键的使用，可以极大方的提高我们的开发效率。</p>
<p>Ctrl+X 删除行<br>Ctrl+D 复制行<br>Ctrl+Shift+N 查找文件<br>Ctrl+Alt+L  格式化代码<br>Ctrl+Alt+O 优化导入的类和包<br>Alt+/ 自动补全代码 注：默认与输入法有冲突，在setting-&gt;keymap-&gt;main menu-&gt;code-&gt;complete code-&gt;basic<br>Ctrl+P 方法参数提示<br>Ctrl+H 显示类结构图<br>Ctrl+Q 显示注释文档<br><a id="more"></a><br>[b]Alt+1 快速打开或隐藏工程面板[/b]<br>F2 或Shift+F2 高亮错误或警告快速定位<br>代码标签输入完成后，按Tab，生成代码。<br>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br>Ctrl+W 选中代码，连续按会增大选择范围<br>Ctrl+Shift+W 取消选中代码，连续按会减小选择范围<br>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br>Ctrl+Up/Down 光标跳转到第一行或最后一行下<br>Ctrl+B 快速打开光标处的类或方法   </p>
<p>Ctrl+Alt+S   设置<br>Ctrl+Alt+Shift+S   项目设置<br>Crtl+Shift+T 创建当前类对应的测试文件</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#IntelliJ快捷键&lt;/p&gt;
&lt;p&gt;IntelliJ号称最好用的Java编辑器，功能确实也够强大，配合上快捷键的使用，可以极大方的提高我们的开发效率。&lt;/p&gt;
&lt;p&gt;Ctrl+X 删除行&lt;br&gt;Ctrl+D 复制行&lt;br&gt;Ctrl+Shift+N 查找文件&lt;br&gt;Ctrl+Alt+L  格式化代码&lt;br&gt;Ctrl+Alt+O 优化导入的类和包&lt;br&gt;Alt+/ 自动补全代码 注：默认与输入法有冲突，在setting-&amp;gt;keymap-&amp;gt;main menu-&amp;gt;code-&amp;gt;complete code-&amp;gt;basic&lt;br&gt;Ctrl+P 方法参数提示&lt;br&gt;Ctrl+H 显示类结构图&lt;br&gt;Ctrl+Q 显示注释文档&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://qiaoweiba.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="IntelliJ" scheme="http://qiaoweiba.com/tags/IntelliJ/"/>
    
  </entry>
  
  <entry>
    <title>JsDemo</title>
    <link href="http://qiaoweiba.com/2017/08/14/1/"/>
    <id>http://qiaoweiba.com/2017/08/14/1/</id>
    <published>2017-08-14T12:18:00.000Z</published>
    <updated>2017-08-14T12:19:12.971Z</updated>
    
    <content type="html"><![CDATA[<!-- 背景动画 -->
<p><script type="text/javascript" src="/js/src/particle.js"></script><br><!-- 背景动画 --></p>
<p><script type="text/javascript" src="/js/src/particle.js"></script><br><img src="/upload_images/1.jpg" alt=""></p>
<blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;!-- 背景动画 --&gt;
&lt;p&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;&lt;br&gt;&lt;!-- 背景动画 --&gt;&lt;/p&gt;
&lt;p&gt;&lt;script type=&quot;text/javascript&quot; s
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://qiaoweiba.com/2017/08/14/hello-world/"/>
    <id>http://qiaoweiba.com/2017/08/14/hello-world/</id>
    <published>2017-08-14T04:47:10.337Z</published>
    <updated>2017-08-14T05:11:56.260Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
