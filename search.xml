<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HashMap源码(Java 8)]]></title>
    <url>%2F2017%2F08%2F28%2F1%2F</url>
    <content type="text"><![CDATA[HashMap源码分析Map作为一种典型的数据结构，是存储key-value键值对的集合类，key可以为null但必须是唯一的。 HashMap实现了Map接口，因此也继承了这一特性。下面我们来分析一下HashMap的主要源码和实现过程，以便对HashMap有更深入的理解。在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题。 声明public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable HashMap实现了Map接口，继承了AbstractMap。AbstractMap实现了Map的主要抽象函数，从而减少了HashMap实现接口的工作量。 属性static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默认初始容量，即桶的数量，16 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 最大容量 static final float DEFAULT_LOAD_FACTOR = 0.75f;// 默认装载因子 static final int TREEIFY_THRESHOLD = 8; //桶中的元素大于此阀值，且HashMap中所有元素总数大于MIN_TREEIFY_CAPACITY时，单向链表转成树（红黑树） static final int UNTREEIFY_THRESHOLD = 6; //当桶中的元素小于此阀值时，树转成单向链表 static final int MIN_TREEIFY_CAPACITY = 64; //HashMap中所有元素总数小于此值时，即使桶中元素超过TREEIFY_THRESHOLD也不转成树 transient Node&lt;K,V&gt;[] table; //桶 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; transient int size; transient int modCount; int threshold; final float loadFactor; 构造函数//指定初始容量和装载因子 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } //指定加载因子 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } //默认构造方法，装载因子为默认值0.75 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } //使用一个Map来初始化一个HashMap public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); } put方法put方法大致思路如下： 对key的hashCode()做hash，然后再计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。 具体代码的实现如下： public V put(K key, V value) { // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; // 直接命中节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 该链为树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 该链为链表 else { for (int binCount = 0; ; ++binCount) { // 没有找到，则新建节点加入链表中 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } // 找到则覆盖原值，并将原值返回 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 容量超过load factor*current capacity，扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } get方法get方法大致思路如下： bucket里直接命中,则返回该处的值； 如果有冲突，则通过key.equals(k)去查找对应的entry: 若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。 具体代码的实现如下： public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 直接命中 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 未命中 if ((e = first.next) != null) { //在树中查找 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //在链表中查找 do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } resize方法final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { // 容量超过最大值就不再扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } //没有超过最大值，就扩容为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 计算新的扩容上限 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; // 扩容后仍为原索引 if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 扩容后为原索引+oldCap else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引+oldCap放到bucket里 if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } hash函数的实现在进行get和put的过程中，都需要计算下标，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，hashCode()计算hash的代码如下： static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。在设计hash函数时，由于table的长度n为2的幂，而计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)： (n - 1) &amp; hash 因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。如果还是产生了频繁的碰撞，使用树来处理频繁的碰撞。 HashMap的常见问题1. HashMap的工作原理通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 2. equals()和hashCode()在HashMap中的作用通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。 3. hash的实现原理及目的在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown笔记]]></title>
    <url>%2F2017%2F08%2F27%2F1%2F</url>
    <content type="text"><![CDATA[段落、标题、区块代码Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。区块引用则使用 ‘&gt;’ 角括号。 A First Level HeaderA Second Level Header Now is the time for all good men to come tothe aid of their country. This is just aregular paragraph. The quick brown fox jumped over the lazydog’s back. Header 3 This is a blockquote. This is the second paragraph in the blockquote. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.This is the first level of quoting. This is nested blockquote. Back to the first level. 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); This is an H3 in a blockquote 修辞和强调星号和底线来标记需要强调的区段 Some of these words are emphasized.Some of these words are emphasized also.Use two asterisks for strong emphasis.Or, if you prefer, use two underscores instead. 列表 Red Green Blue yellow Red Green Blue Bird McHale Parish Bird McHale Parish Bird McHale Parish * This is a list item with two paragraphs. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Aliquam hendreritmi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreetvitae, risus. Donec sit amet nisl. Aliquam semper ipsumsit amet velit. A list item with a blockquote: This is a blockquoteinside a list item. 一列表项包含一个列表区块： &lt;代码写在这&gt; What a great season. 1986. What a great season. Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 行内式： This is [an example](http://example.com/ &quot;Title&quot;) inline link. 参考式： This is [an example][id] reference-style link. [id]: http://example.com/ &quot;Optional Title Here&quot; 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &#39;Optional Title Here&#39; [foo]: http://example.com/ (Optional Title Here) 公式$E=mc^2$$\cos 2\theta = \cos^2 \theta - \sin^2 \theta = 2 \cos^2 \theta - 1$]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJQuickKey]]></title>
    <url>%2F2017%2F08%2F15%2F1%2F</url>
    <content type="text"><![CDATA[#IntelliJ快捷键 IntelliJ号称最好用的Java编辑器，功能确实也够强大，配合上快捷键的使用，可以极大方的提高我们的开发效率。 Ctrl+X 删除行Ctrl+D 复制行Ctrl+Shift+N 查找文件Ctrl+Alt+L 格式化代码Ctrl+Alt+O 优化导入的类和包Alt+/ 自动补全代码 注：默认与输入法有冲突，在setting-&gt;keymap-&gt;main menu-&gt;code-&gt;complete code-&gt;basicCtrl+P 方法参数提示Ctrl+H 显示类结构图Ctrl+Q 显示注释文档[b]Alt+1 快速打开或隐藏工程面板[/b]F2 或Shift+F2 高亮错误或警告快速定位代码标签输入完成后，按Tab，生成代码。选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。Ctrl+W 选中代码，连续按会增大选择范围Ctrl+Shift+W 取消选中代码，连续按会减小选择范围选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。Ctrl+Up/Down 光标跳转到第一行或最后一行下Ctrl+B 快速打开光标处的类或方法 Ctrl+Alt+S 设置Ctrl+Alt+Shift+S 项目设置Crtl+Shift+T 创建当前类对应的测试文件]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>IntelliJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsDemo]]></title>
    <url>%2F2017%2F08%2F14%2F1%2F</url>
    <content type="text"><![CDATA[优秀的人，不是不合群，而是他们合群的人里面没有你]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
